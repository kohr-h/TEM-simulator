/*
 * Copyright 2008-2010, Hans Rullgard, Stockholm University and 
 * Lars-Goran Ofverstedt, Karolinska Institute
 *
 * This file is part of TEM Simulator.
 *
 * TEM Simulator is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * TEM Simulator is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with TEM Simulator.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "macros.h"
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include "geometry.h"
#include "input.h"
#include "log.h"
#include "matrix.h"
#include "misc.h"
#include "particle.h"
#include "particleset.h"
#include "random.h"
#include "sample.h"
#include "simulation.h"

/****************************************************************************/

param_table *geometry_param_table(const char *name);

int geometry_check_input(geometry *g);

int geometry_generate_tilt_data(geometry *g);

int geometry_generate_random_errors(geometry *g);

int geometry_read_data_from_file(geometry *g);

int geometry_write_data_to_file(geometry *g);

int geometry_read_errors_from_file(geometry *g);

int geometry_write_errors_to_file(geometry *g);

/****************************************************************************/

geometry *new_geometry(const char *name){
  geometry *g = malloc(sizeof(geometry));
  g->param = geometry_param_table(name);
  g->data.data = NULL;
  g->errors.data = NULL;
  g->init = 0;
  return g;
}

/****************************************************************************/

void delete_geometry(geometry *g){
  geometry_reset(g);
  delete_param_table(g->param);
  free(g);
}

/****************************************************************************/

param_table *geometry_param_table(const char *name){
  param_table *pt = new_param_table(14, TYPE_GEOMETRY, name);
  add_param_opt_constr(pt, PAR_NTILTS, "l", 1, 1e6);
  add_param_req(pt, PAR_GEN_TILT_DATA, "b");
  add_param_def(pt, PAR_TILT_AXIS, "d", "0");
  add_param_opt(pt, PAR_THETA_START, "d");
  add_param_opt(pt, PAR_THETA_INCR, "d");
  add_param_def(pt, PAR_TILT_MODE, "s," PAR_TILT_MODE__TILTSERIES "," PAR_TILT_MODE__SINGLE_PARTICLE, PAR_TILT_MODE__TILTSERIES);
  add_param_opt(pt, PAR_GEOM_FILE_IN, "s");
  add_param_opt(pt, PAR_GEOM_FILE_OUT, "s");
  add_param_req(pt, PAR_GEOM_ERRORS, "s," PAR_GEOM_ERRORS__NONE "," PAR_GEOM_ERRORS__RANDOM "," PAR_GEOM_ERRORS__FILE);
  add_param_def_constr(pt, PAR_TILT_ERR, "d", "0", 0, HUGE_VAL);
  add_param_def_constr(pt, PAR_ALIGN_ERR_ROT, "d", "0", 0, HUGE_VAL);
  add_param_def_constr(pt, PAR_ALIGN_ERR_TR, "d", "0", 0, HUGE_VAL);
  add_param_opt(pt, PAR_ERROR_FILE_IN, "s");
  add_param_opt(pt, PAR_ERROR_FILE_OUT, "s");
  set_comp_descr(pt, "The geometry component controls how the sample is \
moved from image to image in a tilt series. The movement can be a simple \
rotation around a tilt axis, but much more general tilt geometries can be \
accomplished by reading information from a file. It is also possible to \
impose random errors on the tilt geometry. A geometry component is required \
for simulation of micrographs.");
  set_param_descr(pt, PAR_NTILTS, "The number of images in the tilt series. \
If ntilts is not specified and the tilt geometry is read from a file, the \
number of images is instead determined by the number of lines in the file.");
  set_param_descr(pt, PAR_GEN_TILT_DATA, "Controls whether the tilt geometry \
should be automatically generated or read from a file. If the tilt geometry \
consists of rotations around a fixed tilt axis perpendicular to the optical \
axis it can be automatically generated by specifying the parameters tilt_axis, \
theta_start, and theta_incr. For more complicated geometries it is necessary \
to read input from a text file.");
  set_param_descr(pt, PAR_TILT_AXIS, "The angle in degrees between the x-axis \
and the tilt axis, if the tilt geometry is automatically generated.");
  set_param_descr(pt, PAR_THETA_START, "The tilt angle in degrees of the first \
image, if the tilt geometry is automatically generated.");
  set_param_descr(pt, PAR_THETA_INCR, "The increment of the tilt angle in \
degrees between successive images, if the tilt geometry is automatically \
generated.");
  set_param_descr(pt, PAR_TILT_MODE, "Controls how the tilt geometry is \
applied to the sample. \"" PAR_TILT_MODE__TILTSERIES "\" means that rotations \
are applied to the entire sample and the particle positions. \
\"" PAR_TILT_MODE__SINGLE_PARTICLE "\" means that the sample and particle \
positions stay fixed, while individual particles are rotated around their center.");
  set_param_descr(pt, PAR_GEOM_ERRORS, "Controls whether geometry errors \
should be included, and if the errors should be random or read from a file. \
If the errors are random, their magnitude is controlled by the parameters "
PAR_TILT_ERR ", " PAR_ALIGN_ERR_ROT ", and " PAR_ALIGN_ERR_TR ".");
  set_param_descr(pt, PAR_TILT_ERR, "If " PAR_GEOM_ERRORS " is set to \"" PAR_GEOM_ERRORS__RANDOM "\", \
the sample is rotated a random angle around a random line perpendicular to \
the optical axis. " PAR_TILT_ERR " is the standard deviation of the rotation angle \
measured in degrees.");
  set_param_descr(pt, PAR_ALIGN_ERR_ROT, "If " PAR_GEOM_ERRORS " is set to \"" PAR_GEOM_ERRORS__RANDOM "\", \
the sample is rotated a random angle around the optical axis. " PAR_ALIGN_ERR_ROT
" is the standard deviation of the rotation angle measured in degrees.");
  set_param_descr(pt, PAR_ALIGN_ERR_TR, "If " PAR_GEOM_ERRORS " is set to \"" PAR_GEOM_ERRORS__RANDOM "\", \
the sample is translated a random distance perpendicular to the optical axis. "
PAR_ALIGN_ERR_TR " is the standard deviation of the translation measured in nm.");
  set_param_descr(pt, PAR_GEOM_FILE_IN, "The name of a text file from which the \
tilt geometry is read if gen_tilt_data is set to no.");
  set_param_descr(pt, PAR_GEOM_FILE_OUT, "The name of a text file to which the \
generated tilt geometry is written if gen_tilt_data is set to yes.");
  set_param_descr(pt, PAR_ERROR_FILE_IN, "The name of a text file from which \
geometry errors are read if geom_errors is set to \"" PAR_GEOM_ERRORS__FILE "\".");
  set_param_descr(pt, PAR_ERROR_FILE_OUT, "The name of a text file to which \
the random geometry errors are written if geom_errors is set to \"random\".");
  return pt;
}

/****************************************************************************/

int geometry_init(geometry *g, simulation *sim){
  const char *errors;
  if(g->init) return 0;
  if(geometry_check_input(g)){
    WARNING("Error initializing geometry: incomplete input data.\n");
    return 1;
  }
  g->init = 1;
  if(get_param_boolean(g->param, PAR_GEN_TILT_DATA)){
    if(geometry_generate_tilt_data(g)){
      geometry_reset(g);
      return 1;
    }
    if(param_isset(g->param, PAR_GEOM_FILE_OUT)){
      geometry_write_data_to_file(g);
    }
  }
  else {
    if(geometry_read_data_from_file(g)){
      geometry_reset(g);
      return 1;
    }
  }
  errors = get_param_string(g->param, PAR_GEOM_ERRORS);
  if(0 == strcmp(errors, PAR_GEOM_ERRORS__RANDOM)){
    if(geometry_generate_random_errors(g)){
      geometry_reset(g);
      return 1;
    }
    if(param_isset(g->param, PAR_ERROR_FILE_OUT)){
      geometry_write_errors_to_file(g);
    }
  }
  else if(0 == strcmp(errors, PAR_GEOM_ERRORS__FILE)){
    if(geometry_read_errors_from_file(g)){
      geometry_reset(g);
      return 1;
    }
  }
  else {
    init_matrix(&(g->errors), get_param_long(g->param, PAR_NTILTS), 5);
    fill_matrix(&(g->errors), 0);
  }
  if(0 == strcmp(PAR_TILT_MODE__TILTSERIES, get_param_string(g->param, PAR_TILT_MODE))){
    g->tilt_mode = mode_tiltseries;
  }
  else {
    g->tilt_mode = mode_single_particle;
  }
  param_table_set_lock(g->param, 1);
  write_log_comment("Geometry component initialized.\n\n");
  return 0;
}

/****************************************************************************/

void geometry_reset(geometry *g){
  if(0 == g->init) return;
  free_matrix(&(g->data));
  free_matrix(&(g->errors));
  param_table_set_lock(g->param, 0);
  g->init = 0;
}

/****************************************************************************/

int geometry_check_input(geometry *g){
  const char *errors;
  if(check_params(g->param)) return 1;
  if(get_param_boolean(g->param, PAR_GEN_TILT_DATA)){
    if(require_param(g->param, PAR_THETA_START) || require_param(g->param, PAR_THETA_INCR)
       || require_param(g->param, PAR_NTILTS)) return 1;
  }
  else {
    if(require_param(g->param, PAR_GEOM_FILE_IN)) return 1;
  }
  errors = get_param_string(g->param, PAR_GEOM_ERRORS);
  if(0 == strcmp(errors, PAR_GEOM_ERRORS__RANDOM)){
    if(require_param(g->param, PAR_TILT_ERR) || require_param(g->param, PAR_ALIGN_ERR_ROT) 
       || require_param(g->param, PAR_ALIGN_ERR_TR)) return 1;
  }
  else if(0 == strcmp(errors, PAR_GEOM_ERRORS__FILE)){
    if(require_param(g->param, PAR_ERROR_FILE_IN)) return 1;
  }
  return 0;
}

/****************************************************************************/

int geometry_write_log(geometry *g){
  return write_parameters_to_log(g->param);
}

/****************************************************************************/

int geometry_generate_tilt_data(geometry *g){
  int i;
  long ntilts;
  double theta, theta_incr, tilt_axis;
  if(0 == g->init){
    WARNING("Error generating geometry tilt data: Geometry component has not been initialized.\n");
    return 1;
  }
  ntilts = get_param_long(g->param, PAR_NTILTS);
  init_matrix(&(g->data), ntilts, 3);
  theta = ANGLE_UNIT * get_param_double(g->param, PAR_THETA_START);
  theta_incr = ANGLE_UNIT * get_param_double(g->param, PAR_THETA_INCR);
  tilt_axis = ANGLE_UNIT * get_param_double(g->param, PAR_TILT_AXIS);
  for(i = 0; i < g->data.m; i++, theta += theta_incr){
    set_matrix_entry(&(g->data), i, 0, -tilt_axis);
    set_matrix_entry(&(g->data), i, 1, theta);
    set_matrix_entry(&(g->data), i, 2, tilt_axis);
  }
  return 0;
}

/****************************************************************************/

int geometry_generate_random_errors(geometry *g){
  long ntilts;
  int i;
  double align_err_rot, align_err_tr, tilt_err, tilt_axis = 0;
  if(0 == g->init){
    WARNING("Error generating random geometry errors: Geometry component has not been initialized.\n");
    return 1;
  }
  ntilts = get_param_long(g->param, PAR_NTILTS);
  init_matrix(&(g->errors), ntilts, 5);
  align_err_rot = ANGLE_UNIT * get_param_double(g->param, PAR_ALIGN_ERR_ROT);
  align_err_tr = sqrt(0.5) * get_param_double(g->param, PAR_ALIGN_ERR_TR);
  tilt_err = ANGLE_UNIT * get_param_double(g->param, PAR_TILT_ERR);
  for(i = 0; i < g->errors.m; i++){
    set_matrix_entry(&(g->errors), i, 0, rand_gauss(0, align_err_rot));
    if(tilt_err != 0){
      tilt_axis = rand_uniform(0, M_PI);
    }
    set_matrix_entry(&(g->errors), i, 1, tilt_axis);
    set_matrix_entry(&(g->errors), i, 2, rand_gauss(0, tilt_err));
    set_matrix_entry(&(g->errors), i, 3, rand_gauss(0, align_err_tr));
    set_matrix_entry(&(g->errors), i, 4, rand_gauss(0, align_err_tr));
  }
  return 0;
}

/****************************************************************************/

int geometry_read_data_from_file(geometry *g){
  double conv[3];
  long ntilts;
  if(0 == g->init){
    WARNING("Error reading geometry data file: Geometry component has not been initialized.\n");
    return 1;
  }
  conv[0] = conv[1] = conv[2] = ANGLE_UNIT;
  if(read_matrix_text_conv(&(g->data), get_param_string(g->param, PAR_GEOM_FILE_IN), 3, conv)) return 1;
  if(param_isset(g->param, PAR_NTILTS)){
    ntilts = get_param_long(g->param, PAR_NTILTS);
  }
  else {
    ntilts = g->data.m;
    set_param_long(g->param, PAR_NTILTS, ntilts);
    write_log_comment("Number of tilts read from geometry data file: %i.\n", (int)ntilts);
  }
  if(shrink_matrix(&(g->data), ntilts, 3)){
    WARNING("Too few data in geometry data input file %s.\n", get_param_string(g->param, PAR_GEOM_FILE_IN));
    return 1;
  }
  return 0;
}

/****************************************************************************/

int geometry_write_data_to_file(geometry *g){
  double conv[3];
  if(0 == g->init){
    WARNING("Error writing geometry data file: Geometry component has not been initialized.\n");
    return 1;
  }
  conv[0] = conv[1] = conv[2] = ANGLE_UNIT;
  return write_matrix_text_conv(&(g->data), get_param_string(g->param, PAR_GEOM_FILE_OUT),
				3, conv, 3, "psi", "theta", "phi");
}

/****************************************************************************/

int geometry_read_errors_from_file(geometry *g){
  double conv[3];
  long ntilts;
  if(0 == g->init){
    WARNING("Error reading geometry error file: Geometry component has not been initialized.\n");
    return 1;
  }
  conv[0] = conv[1] = conv[2] = ANGLE_UNIT;
  ntilts = get_param_long(g->param, PAR_NTILTS);
  if(read_matrix_text_conv(&(g->errors), get_param_string(g->param, PAR_ERROR_FILE_IN), 3, conv)) return 1;
  if(shrink_matrix(&(g->data), ntilts, 3)){
    WARNING("Too few data in geometry error input file %s.\n", get_param_string(g->param, PAR_ERROR_FILE_IN));
    return 1;
  }
  return 0;
}

/****************************************************************************/

int geometry_write_errors_to_file(geometry *g){
  double conv[3];
  if(0 == g->init){
    WARNING("Error writing geometry error file: Geometry component has not been initialized.\n");
    return 1;
  }
  conv[0] = conv[1] = conv[2] = ANGLE_UNIT;
  return write_matrix_text_conv(&(g->errors), get_param_string(g->param, PAR_ERROR_FILE_OUT),
				3, conv, 5, "rot", "axis", "ang", "x", "y");
}

/****************************************************************************/

int set_proj_matrix(matrix *pm, geometry *g, long tilt){
  double v;
  if(0 == g->init){
    WARNING("Error in set_proj_matrix: Geometry component has not been initialized.\n");
    return 1;
  }
  if((pm->m != 3)||(pm->n != 3)){
    WARNING("Error in set_proj_matrix: invalid size of pm. Matrix must be 3x3.\n");
    return 1;
  }
  if((tilt < 0)||(tilt >= g->data.m)){
    WARNING("Error in set_proj_matrix: tilt number out of range.\n");
    return 1;
  }
  fill_matrix_diag(pm, 1);
  rotate3drows(pm, 0, 0, 1, -get_matrix_entry(&(g->errors), tilt, 0));
  v = get_matrix_entry(&(g->errors), tilt, 1);
  rotate3drows(pm, cos(v), sin(v), 0, -get_matrix_entry(&(g->errors), tilt, 2));
  rotate3drows(pm, 0, 0, 1, -get_matrix_entry(&(g->data), tilt, 2));
  rotate3drows(pm, 1, 0, 0, -get_matrix_entry(&(g->data), tilt, 1));
  rotate3drows(pm, 0, 0, 1, -get_matrix_entry(&(g->data), tilt, 0));
  return 0;
}

/****************************************************************************/

int get_particle_geom(matrix *pm, double pos[3], particleset *ps, long i, geometry *g, long tilt){
  double x[3];
  long j, k;
  if(0 == g->init){
    WARNING("Error in get_particle_geom: Geometry component has not been initialized.\n");
    return 1;
  }
  if(0 == ps->init){
    WARNING("Error in get_particle_geom: Particleset component has not been initialized.\n");
    return 1;
  }
  if((pm->m != 3)||(pm->n != 3)){
    WARNING("Error in get_particle_geom: invalid size of pm. Matrix must be 3x3.\n");
    return 1;
  }
  if((tilt < 0)||(tilt >= g->data.m)){
    WARNING("Error in get_particle_geom: tilt number out of range.\n");
    return 1;
  }
  if((i < 0)||(i >= ps->coordinates.m)){
    WARNING("Error in get_particle_geom: particle number out of range.\n");
    return 1;
  }
  if(set_proj_matrix(pm, g, tilt)) return 1;
  if(get_particle_pos(x, ps, i)) return 1;
  pos[0] = get_matrix_entry(&(g->errors), tilt, 3);
  pos[1] = get_matrix_entry(&(g->errors), tilt, 4);
  pos[2] = 0;
  if(g->tilt_mode == mode_tiltseries){
    for(j = 0; j < 3; j++){
      for(k = 0; k < 3; k++){
	pos[j] += x[k] * get_matrix_entry(pm, j, k);
      }
    }
  }
  else {
    for (j = 0; j < 3; j++){
      pos[j] += x[j];
    }
  }
  if(rotate_particle(pm, ps, i)) return 1;
  return 0;
}

/****************************************************************************/

int get_sample_geom(matrix *pm, double pos[3], sample *s, geometry *g, long tilt){
  double x[2];
  long j, k;
  if(0 == g->init){
    WARNING("Error in get_sample_geom: Geometry component has not been initialized.\n");
    return 1;
  }
  if(0 == s->init){
    WARNING("Error in get_sample_geom: Particleset component has not been initialized.\n");
    return 1;
  }
  if((pm->m != 3)||(pm->n != 3)){
    WARNING("Error in get_sample_geom: invalid size of pm. Matrix must be 3x3.\n");
    return 1;
  }
  if((tilt < 0)||(tilt >= g->data.m)){
    WARNING("Error in get_sample_geom: tilt number out of range.\n");
    return 1;
  }
  if(g->tilt_mode == mode_tiltseries){
    if(set_proj_matrix(pm, g, tilt)) return 1;
  }
  else {
    fill_matrix_diag(pm, 1);
  }
  x[0] = get_param_double(s->param, PAR_OFFSET_X);
  x[1] = get_param_double(s->param, PAR_OFFSET_Y);
  pos[0] = get_matrix_entry(&(g->errors), tilt, 3);
  pos[1] = get_matrix_entry(&(g->errors), tilt, 4);
  pos[2] = 0;
  for(j = 0; j < 3; j++){
    for(k = 0; k < 2; k++){
      pos[j] += x[k] * get_matrix_entry(pm, j, k);
    }
  }
  return 0;
}

